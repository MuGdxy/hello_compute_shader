#version 450
#extension GL_GOOGLE_include_directive: enable
#extension GL_EXT_debug_printf : enable

#include "Random.comph"
#include "Ray.comph"
#include "Material.comph"
#include "Hittable.comph"
#include "Camera.comph"

const int blockSizeX = 32;
const int blockSizeY = 32;
layout (local_size_x = blockSizeX, local_size_y = blockSizeY) in;

layout(push_constant, std140) uniform PushConstant 
{
    ivec2 screenSize;
    uint hittableCount;
    uint samples;
    uint maxDepth;
};

layout(set = 0, binding = 0) writeonly buffer TargetBuffer
{
    vec4 pixels[];
} target;

layout(set = 0, binding = 1, std140) readonly buffer MaterialBuffer
{
    Material materials[];
};

layout(set = 0, binding = 2, std140) readonly buffer MaterialDumpBuffer
{
    vec4 data[];
} materialData;

layout(set = 0, binding = 3, std140) readonly buffer HittableBuffer
{
    Hittable hittables[];
};

layout(set = 0, binding = 4, std140) readonly buffer HittableDumpBuffer
{
    vec4 data[];
} hittableData;

layout(set = 1, binding = 0, std140) uniform CameraBuffer
{
    Camera camera;
};

bool Hit(Hittable hittable, Ray r, float t_min, float t_max, out HitRecord rec);
bool Hit(Ray r, float t_min, float t_max, out HitRecord rec);
bool Scatter(Material self, Ray r_in, HitRecord rec, out vec3 attenuation, out Ray scattered);

vec3 BackgroundColor(Ray r);
void WriteColor(int x, int y, vec3 color);

vec3 RayColor(Ray r)
{
    vec3 color = vec3(1.0);
    Ray next = r;
    int x = 0;

    for(int i = 0; i < maxDepth; ++i)
    {
        HitRecord rec;
        if(Hit(next, 0.001, 10000, rec))
        {
            vec3 attenuation;   
            if(Scatter(rec.mat, next, rec, attenuation, next))
                color *= attenuation;
            else return vec3(0);
        }
        else return color * BackgroundColor(next);
    }
    return vec3(0);
}


void main()
{
    Seed(gl_GlobalInvocationID.xy, screenSize);

    if(gl_GlobalInvocationID.x >= screenSize.x
        || gl_GlobalInvocationID.y >= screenSize.y) return;
    int i = int(gl_GlobalInvocationID.x);
    int j = int(gl_GlobalInvocationID.y);

    vec3 color = vec3(0);

    for(int sam = 0; sam < samples; ++sam)
    {
        float s = (float(i) +Rand()) / (screenSize.x - 1);
        float t = (float(screenSize.y - j - 1) + Rand()) / (screenSize.y - 1);
        Ray r = GetRay(camera, s, t);
        color += RayColor(r);
    }

    color /= samples;
    WriteColor(i, j, color);
}


bool Scatter(Material self, Ray r, HitRecord rec, out vec3 attenuation, out Ray scattered)
{
    switch(self.type)
    {
    case MaterialEnum.Lambertian:
        Lambertian lam;
        Init(lam, materialData.data[self.ptr].xyz);
        return Scatter(lam, r, rec, attenuation, scattered);
    case MaterialEnum.Metal:
        Metal met;
        vec4 d = materialData.data[self.ptr];
        Init(met, d.xyz, d.w);
        return Scatter(met, r, rec, attenuation, scattered);
    case MaterialEnum.Dielectrics:
        Dielectrics dlt;
        Init(dlt,materialData.data[self.ptr].x);
        return Scatter(dlt, r, rec, attenuation, scattered);
    }
    return false;
}

bool Hit(Hittable hittable, Ray r, float t_min, float t_max, out HitRecord rec)
{
    switch(hittable.type)//disptach
    {
    case HittableEnum.Sphere:
        Sphere s;
        vec3 center =  hittableData.data[hittable.ptr].xyz;
        float radius =  hittableData.data[hittable.ptr].w;
        Init(s, center, radius);
        return Hit(s, r, t_min, t_max, rec);
    default:
        return false;
    }
}

bool Hit(Ray r, float t_min, float t_max, out HitRecord rec)
{
    HitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for (int i = 0; i < hittableCount; ++i) 
    {
        Hittable obj = hittables[i];
        if(Hit(obj, r, t_min, closest_so_far, temp_rec))
        {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            temp_rec.mat = materials[obj.mat];
            rec = temp_rec;
        }
    }
    return hit_anything;
}


vec3 BackgroundColor(Ray r) 
{
    vec3 dir = r.direction;
    float t = 0.5*(dir.y + 1.0);
    return mix(vec3(1.0,1.0,1.0),vec3(209.0/255.0,227.0/255.0,254.0/255.0), t);
}


void WriteColor(int x, int y, vec3 color) 
{ 
    //gamma correct
    color = sqrt(color);
    target.pixels[y * screenSize.x + x] = vec4(color,1.0);
}