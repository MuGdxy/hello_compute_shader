#version 450
#extension GL_GOOGLE_include_directive: enable
#include "Random.comph"
#include "Ray.comph"
#include "Material.comph"
#include "Sphere.comph"
#include "Camera.comph"

const int blockSizeX = 32;
const int blockSizeY = 32;
layout (local_size_x = blockSizeX, local_size_y = blockSizeY) in;


struct World
{
    Sphere object[10];
    int count;
};

layout(push_constant) uniform PushConstant 
{
    ivec2 screenSize;
};
const int samples = 200;
const int maxDepth = 800;

layout(set = 0, binding = 0) buffer TargetBuffer
{
    vec4 pixels[];
} target;

layout(set = 0, binding = 1, std140) uniform CameraBuffer
{
    Camera camera;
};

// layout(set = 1, binding = 0, std140) readonly buffer LambertianBuffer
// {
//     Lambertian lambertians[];
// };

// layout(set = 1, binding = 0, std140) readonly buffer GeometryBuffer
// {
//    int count;
//    Sphere spheres[];
// };

bool Hit(World self, Ray r, float t_min, float t_max, out HitRecord rec);

vec3 BackgroundColor(Ray r);
void WriteColor(int x, int y, vec3 color);

World world;

void SetupWorld()
{
    Material m;
    m.type = MaterialEnum.Lambertian;
    m.ptr = 0;

    lambertians[0].albedo = vec3(0.5);

    Init(world.object[0], vec3(0, 0, -1), 0.5);
    world.object[0].mat = m;

    Init(world.object[1], vec3(0,-100.5,-1), 100);
    world.object[1].mat = m;
    world.count = 2;
}

vec3 RayColor(Ray r, World world)
{
    vec3 color = vec3(1.0);
    Ray next = r;
    for(int i = 0; i < maxDepth; ++i)
    {
        HitRecord rec;
        if(Hit(world, next, 0.001, 10000, rec))
        {
            vec3 attenuation;
            if(scatter(rec.mat, r, rec, attenuation, next))
                color *= attenuation;
            else return vec3(0);
        }
        else return color * BackgroundColor(next);
    }
    return vec3(0);
}


void main()
{
    Seed(gl_GlobalInvocationID.xy, screenSize);

    SetupWorld();

    if(gl_GlobalInvocationID.x >= screenSize.x
        || gl_GlobalInvocationID.y >= screenSize.y) return;
    int i = int(gl_GlobalInvocationID.x);
    int j = int(gl_GlobalInvocationID.y);

    vec3 color = vec3(0);

    for(int sam = 0; sam < samples; ++sam)
    {
        float v = (float(screenSize.y - j - 1) + Rand()) / (screenSize.y - 1);
        float u = (float(i) + Rand()) / (screenSize.x - 1);
        Ray r = GetRay(camera, u, v);
        color += RayColor(r, world);
    }

    color /= samples;
    WriteColor(i, j, color);
}


/*
    World Method Implementation
*/
bool Hit(World self, Ray r, float t_min, float t_max, out HitRecord rec)
{
    HitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for (int i = 0; i < self.count; ++i) 
    {
        Sphere o = self.object[i];
        if(Hit(o,r,t_min, closest_so_far, temp_rec))
        {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }
    return hit_anything;
}


vec3 BackgroundColor(Ray r) 
{
    vec3 dir = r.direction;
    float t = 0.5*(dir.y + 1.0);
    return mix(vec3(1.0,1.0,1.0),vec3(0.5, 0.7, 1.0), t);
}


void WriteColor(int x, int y, vec3 color) 
{ 
    color = sqrt(color);
    target.pixels[y * screenSize.x + x] = vec4(color,1.0);
}